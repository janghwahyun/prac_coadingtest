// 백트래킹
// 해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더 이상 가지 않고 되돌아가서 다시 해를 찾는 기법이다.
// 이를 '가지치기'라고 하는데, 불필요한 부분을 쳐내고 최대한 올바른 쪽으로 간다는 의미이다.
// 즉, 반복문의 횟수를 줄일 수 있으므로 효율적이다.

// 문제의 예시처럼 1,2,4,8,9 라는 좌표가 주어졌을 때를 생각해보자.

// 최소 간격은 1이고, 최대 간격은 8이다.

// 따라서 1~8 사이에 우리가 원하는 정답이 있다.

// B.S를 적용하기 위해 mid = (1+8)/2 --> 4 로 설정하자. 이는, 가장 가까운 집 사이의 간격이 4가 되도록 공유기를 설치하겠다는 의미이다.

// 따라서 공유기를 직접 설치하는 알고리즘이 필요하다.

// [공유기 설치 알고리즘]

// 예시 :[1,2,4,8,9]

// 1. 가장 먼저 Base Case로 1이라는 위치에 공유기를 설치해놓는다.

// 2. 2라는 위치에 공유기를 설치하면 간격이 1이 되므로 설치하지 않는다.

// 3. 4라는 위치에 공유기를 설치하면 간격이 3가 되므로 설치하지 않는다.

// 4. 8이라는 위치에 공유기를 설치하면 간격이 7이 되므로 설치한다.

// 5. 9라는 위치에 공유기를 설치하면 간격이 1이 되므로 설치하지 않는다. ** 간격 : 9-8

// ----------------------------------------------------------------------------------

// 이 공유기 설치 알고리즘이 끝나고 나면, 공유기의 갯수를 파악한다.

// 만약, 공유기의 갯수가 C보다 작다면 공유기의 '간격(mid)'을 더 작게(촘촘하게) 설치해야 한다.

// 반대로, 공유기의 갯수가 C보다 크다면, 공유기의 '간격(mid)'을 좀 더 크게 설치할 수 있다.

// 잘 생각해보면, 공유기의 갯수가 C와 일치하더라도, 공유기의 '간격(mid)'을 좀 더 크게 설치해볼 필요성이 있다.

// 설치되는 공유기의 갯수가 C보다 크거나 같을 때 모두 정답이 될 수 있으므로, ans라는 변수에 계속 대입해주는 것이 좋다.
// 이 과정을 코드로 작성하면 다음과 같다.
